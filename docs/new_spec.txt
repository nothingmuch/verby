
Problems with Algorithm::Dependency:

- it does not deal with or detect circular dependencies
- it deals with $ids and not with $objects

Centralized vs. Decentralized:

I would like for this module/framework to have the capability of havig both centralized and decentralized control, as there are benefits to both approaches, and we should not force the user into one or the other.

First some defintions;

- Centralized control implies that all the actions and dependency relationships are set up from a single location. Thereby keeping the majority of the complexity in one place.

- Decentralized control implies that each step (action + depenedency) is responsible for it's own information and interdependencies. 

How to:

We can achieve centralized control simply by writing the script which strings all the objects together in one place. Or through some kind of configuration format which then generates the that tree.

We can achieve decentralized control through subclassing. Simply by overriding some methods in our dependency and action objects we can give them the capabilities needed. 

What we need:

- Action objects

These are objects which encapsulte an action of some kind. The action should be reversable/transactional. They should support re-starting of the action (meaning they clean up, then restart). And it should be able to determine if it successfully completed.

Action objects should contain no dependency information, and are essentially "dumb" objects. They simple perform their task and assume that their environment is taken care of. They can be passed some configuration data if needed, or they can be hardcoded. 

- Dependency objects

These objects are the means by which Actions can be combined. A Dependency object contains at least one Action object which it will run if all it's dependencies are satisfied. If a dependency object contains more than one action, it is assumed that they can either be run in order or in parallell (in other words they have no dependencies between them other than the dependecies of their parent (the Dependency object)). 

A dependency is assumed to be satisfied if all it's actions have completed successfully. Any additional checks for completion can be implemented as Actions.

Dependency objects can also contain other dependency objects. This allows for a series of inter-dependent dependencies to be grouped together, and still isolate them from the other dependencies. This will actually be encapsulated by a Dependency runner Action object.

What do we do with this:

First we can analyze the dependency tree fairly easily with this structure. Which would facilitate dry runs as well as testability. We can also catch circular dependencies as well (assuming that a circular dependency can be deduced by the presence of identical actions in the dependency graph).

Next, this allows is to isolate the simple from the complex. Simple actions, combined in complex dependency situations. However, this complexity can also be managed by nesting dependency objects into dependency groups.

Since actions are no longer coupled to their dependencies, they need not be singletons anymore. Which means we can have more general purpose actions which can be re-used with different configurations.

How do we run this:

Visitor objects should be able to do all our work for us. We can write visitors to check for circular dependencies, for doing test runs, etc. It also allows us to isolate the complexity of doing the 'make' like reentrant behavior, into a Visitor object. This means that both our Action objects and our Dependency objects need not know about this behavior.

So what does this all look like: 
                                
    my $base_dir = Dependency->new();                    
    $base_dir->addAction(Action::MkPath->new('/var/www'));

    my $project_tree = Dependency->new();                    
    $project_tree->addAction(Action::MkDirTree->new(...));
    $project_tree->depends_on($base_dir); # adds $project_tree to $base_dir's dependencies

    +--------------+
    |  Dependency  |
    +--------------+      +----------------+
    | actions      |----->| Action::MkPath |   
    | dependenants |--+   +----------------+
    +--------------+  |  
                      |    +--------------+        
                      +--->|  Dependency  | 
                           +--------------+    +-------------------+
                           | actions      |--->| Action::MkDirTree |
                           | dependenants |    +-------------------+
                           +--------------+

Pre-order traversal of this tree will process dependencies in the correct order. This basically means that all the of the parents must be satisfied before thier children. So in this example, Action::MkPath must be completed before Action::MkDirTree can be run.

Misc. Thoughts:

* Maybe Dependency should be called Step? Each step depending upon it's own sub-steps.

* What if a parent Step/Dependency has information that a child needs how do we handle that?

  - A given Visitor object might encapsulate certain aspects such as a database connection.
    This would mean moving something which might fit within the hierarchy up into the Visitor 
    object instead. Maybe as part of a general config? 
    
  - Should the Visitor hold some global config data? Would it couple the Actions to the Visitors
    to much if we were to pass the Visitor to the Action? Or should we create some basic Context
    or Environment object which the Visitor object has, but the Action object uses.




